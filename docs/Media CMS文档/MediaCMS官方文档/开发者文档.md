# 开发者文档

## 目录

- [1. 欢迎](https://tencent.yuanbao/chat?from=launch&conversation=8771049d-4ff7-4316-83a8-3d6233e904d8&project_id=&project_name=&HY82=2&HY56=SlidePage#1-欢迎)
- [2. 系统架构](https://tencent.yuanbao/chat?from=launch&conversation=8771049d-4ff7-4316-83a8-3d6233e904d8&project_id=&project_name=&HY82=2&HY56=SlidePage#2-系统架构)
- [3. API 文档](https://tencent.yuanbao/chat?from=launch&conversation=8771049d-4ff7-4316-83a8-3d6233e904d8&project_id=&project_name=&HY82=2&HY56=SlidePage#3-api-文档)
- [4. 如何贡献](https://tencent.yuanbao/chat?from=launch&conversation=8771049d-4ff7-4316-83a8-3d6233e904d8&project_id=&project_name=&HY82=2&HY56=SlidePage#4-如何贡献)
- [5. 使用 Docker 的技巧](https://tencent.yuanbao/chat?from=launch&conversation=8771049d-4ff7-4316-83a8-3d6233e904d8&project_id=&project_name=&HY82=2&HY56=SlidePage#5-使用-docker-的技巧)
- [6. 使用自动化测试](https://tencent.yuanbao/chat?from=launch&conversation=8771049d-4ff7-4316-83a8-3d6233e904d8&project_id=&project_name=&HY82=2&HY56=SlidePage#6-使用自动化测试)
- [7. 视频转码流程](https://tencent.yuanbao/chat?from=launch&conversation=8771049d-4ff7-4316-83a8-3d6233e904d8&project_id=&project_name=&HY82=2&HY56=SlidePage#7-视频转码流程)

## 1. 欢迎

本页面是为 MediaCMS 开发者创建的，包含相关信息。

## 2. 系统架构

待编写

## 3. API 文档

API 使用 Swagger 进行文档化 - 请访问 http://your_installation/swagger- 例如 https://demo.mediacms.io/swagger/

此页面允许您登录以执行需要身份验证的操作 - 如果您已登录，它也会使用您的会话。

使用 Python requests 库的示例：

```
import requests

auth = ('user' ,'password')
upload_url = "https://domain/api/v1/media"
title = 'x title'
description = 'x description'
media_file = '/tmp/file.mp4'

requests.post(
    url=upload_url,
    files={'media_file': open(media_file,'rb')},
    data={'title': title, 'description': description},
    auth=auth
)
```

## 4. 如何贡献

在您发送 PR 之前，请确保您的代码格式正确。为此，请使用 `pre-commit install`安装预提交钩子，并运行 `pre-commit run --all`并在提交前修复所有问题。此预提交钩子将在您每次提交代码时检查代码规范。

如果您想为此代码库做贡献，请查看[行为准则页面](https://tencent.yuanbao/CODE_OF_CONDUCT.md)

## 5. 使用 Docker 的技巧

要执行 Docker 安装，请按照说明安装 Docker + Docker Compose (docs/Docker_Compose.md)，然后构建/启动 docker-compose-dev.yaml。这将在所有其他容器（包括端口 80 上的 Django Web 应用程序）之上，在端口 8088 上运行前端应用程序。

```
docker compose -f docker-compose-dev.yaml build
docker compose -f docker-compose-dev.yaml up
```

在安装过程中会创建一个 `admin`用户。其属性在 `docker-compose-dev.yaml`中定义：

```
ADMIN_USER: 'admin'
ADMIN_PASSWORD: 'admin'
ADMIN_EMAIL: 'admin@localhost'
```

### 前端应用程序更改

例如，更改 `frontend/src/static/js/pages/HomePage.tsx`，开发应用程序会在几秒钟内刷新（热重载），我可以看到更改，当我满意后，可以运行

```
docker compose -f docker-compose-dev.yaml exec -T frontend npm run dist
```

然后，为了通过 nginx 提供服务时能在应用程序中看到更改，

```
cp -r frontend/dist/static/* static/
```

POST 调用：无法通过开发服务器执行，您必须通过常规应用程序（端口 80）进行调用，然后在端口 8088 的开发应用程序上查看更改。

确保 URL 在 `frontend/.env`中设置，如果不同于 localhost

媒体页面：需要通过主应用程序（nginx/端口 80）上传内容，然后为 media.html 页面使用一个 id，例如 `http://localhost:8088/media.html?m=nc9rotyWP`

还有一些 CORS 问题需要解决，以便某些页面能够正常运行，例如管理评论页面

```
http://localhost:8088/manage-media.html manage_media
```

### 后端应用程序更改

在我对 django 应用程序进行更改后（例如，更改 `files/forms.py`），为了看到更改，我必须重新启动 web 容器

```
docker compose -f docker-compose-dev.yaml restart web
```

## 7. 视频转码流程

原始文件上传到应用程序服务器，并作为 FileFields 存储在那里。

如果文件是视频且持续时间大于某个数值（在设置中定义，我认为是 4 分钟），它们也会被分成多个分块，因此对于所有启用的 EncodeProfiles，每个分块对应一个 Encode 对象。

然后工作进程开始获取 Encode 对象并转码这些分块，因此如果一个分块被成功转码，原始文件（小分块）将被转码后的文件替换，并且 Encode 对象的状态被标记为 'success'。

original.mp4 (1G, 720px)--> Encode1 (100MB, 240px, chunk=True), Encode2 (100MB, 240px, chunk=True)...EncodeXX (100MB, 720px, chunk=True) ---> 当某个分辨率的所有 Encode 对象都成功时，它们会被连接成 original_resolution.mp4 文件，并存储为 Encode 对象 (chunk=False)。这就是可供下载的文件。

显然，Encode 对象用于存储最终提供服务的已编码文件 (chunk=False, status='success')，但也用于存储正在转码过程中的文件 (chunk=True, status='pending/etc')

（括号开始）

还有一个实验性的小服务（目前尚未提交到代码库）仅通过 API 进行通信，并且 a) 获取要运行的任务，b) 返回结果。因此，它发出一个请求并接收一个 ffmpeg 命令以及一个文件，它运行该 ffmpeg 命令，并返回结果。我曾在一些安装中使用此机制，通过更多服务器/CPU 来迁移现有视频，并且只遇到一个问题，需要从服务器中删除一些临时文件（通过周期性任务，问题不大）

（括号结束）

当 Encode 对象被标记为成功且 chunk=False，并因此可供下载/流式传输时，会启动一个任务并保存文件的 HLS 版本（1 个 mp4--> x 个小 .ts 分块）。这将是 FILES_C。

此机制允许多个工作进程（可以访问同一文件系统，无论是本地主机还是通过共享网络文件系统，例如 NFS/EFS）同时工作并产生结果。

## 6. 使用自动化测试

这些说明假设您正在使用 Docker 安装

1. 启动 docker-compose

```
docker compose up
```

1. 在 web 容器上安装 `requirements-dev.txt`中的要求（我们将使用 web 容器进行此操作）

```
docker compose exec -T web pip install -r requirements-dev.txt
```

1. 现在您可以运行现有测试

```
docker compose exec --env TESTING=True -T web pytest
```

传递 `TESTING=True`是为了让 Django 知道这是一个测试环境（例如，以便它将 Celery 任务作为函数运行，而不是作为后台任务运行，因为在 pytest 的情况下 Celery 没有启动）

1. 您可以通过指定路径来尝试单个测试，例如

```
docker compose exec --env TESTING=True -T web pytest tests/test_fixtures.py
```

1. 您还可以查看覆盖率

```
docker compose exec --env TESTING=True -T web pytest --cov=. --cov-report=html
```

当然……我们非常欢迎您帮助我们提高覆盖率 ;)